//
//  Copyright (c) 2011 Tweak Software.
//  All rights reserved.
//
//  SPDX-License-Identifier: Apache-2.0
//
//
#include <IPCore/ShaderProgram.h>
#include <IPCore/ShaderState.h>
#include <IPCore/IPImage.h>
#include <TwkGLF/GL.h>
#include <TwkUtil/Timer.h>
#include <assert.h>
#include <set>
#include <sstream>
#include <iomanip>
#include <boost/algorithm/string.hpp>
#include <boost/algorithm/string/regex.hpp>
#include <boost/functional/hash.hpp>

namespace IPCore
{
    namespace Shader
    {
        using namespace std;
        using namespace TwkFB;
        using namespace boost;
        using namespace TwkUtil;

        namespace
        {
            Timer shaderClock(true);
        }

        Program::Program(Expression* expr)
            : m_expr(expr)
            , m_main(0)
            , m_needOutputSize(false)
            , m_needOutputST(false)
            , m_totalST(0)
        {
            m_localFunctions.push_back(LocalFunction("main", "", expr));
            collectSymbolNames(expr, 0);
        }

        void Program::collectSymbolNames(const Expression* expr,
                                         size_t localFunctionIndex)
        {
            //
            //  Assign (human readable) unique names to all parameters. A
            //  simpler way to do this is to just use the pointer value of the
            //  symbol as the variable name. Unfortunately, that's not easy to
            //  debug so its worth going through the trouble of doing this
            //  instead.
            //
            //  names start as "FOO_0" for symbol "FOO" and increase in number
            //  suffix for repeated use of names. I.e. "FOO_1", "FOO_2", etc.
            //
            //  "Built-in" symbols like "frame" are unique and left as is.
            //
            //  m_totalST needs to indicate how many ST coordinates are to be
            //  passed into the program. Samplers that are associated with
            //  primary image planes require unique STs; for example a
            //  sub-sampled Y U V image has one set of STs for Y and derives the
            //  U+V STs from Y's.
            //
            //  Only source function sampler parameters are allowed to have STs
            //  generated by the renderer, all other samplers must have have
            //  some indirect mechanism or use existing ones.
            //

            //
            //  The passed in Expression tree is "unbound" so any
            //  BoundSymbols appearing in it are definitely BoundExpressions
            //

            const ArgumentVector& exprArgs = expr->arguments();
            const Function* F = expr->function();
            const bool source = F->type() == Function::Source;
            const bool morphological =
                F->type() == Function::MorphologicalFilter;
            const bool inlined = F->isInline();
            const bool samples = F->usesSampling();

            for (size_t i = 0; i < exprArgs.size(); i++)
            {
                if (BoundExpression* B =
                        dynamic_cast<BoundExpression*>(exprArgs[i]))
                {
                    //
                    //  Currently only Symbol::InputImageTypes are expressions
                    //

                    const Expression* fexpr = B->value();

                    if (inlined)
                    {
                        //
                        //  This expression is an InputImageType. A unique
                        //  sampler function will be created. In the case
                        //  where F->isColor() is true, the sampler function
                        //  will not be emitted and LocalFunction is used to
                        //  track Size and TexCoord
                        //

                        if (const Function::ImageParameterInfo* pinfo =
                                F->imageParameterInfo(i))
                        {
                            if (pinfo->usesST)
                                m_outputSTSet.insert(fexpr->graphID());
                            if (pinfo->usesSize)
                                m_outputSizeSet.insert(fexpr->graphID());

                            ostringstream name;
                            name << "_samplerExpr" << m_localFunctions.size();

                            size_t newIndex = m_localFunctions.size();
                            m_localFunctions.push_back(
                                LocalFunction(name.str(), fexpr->graphID(),
                                              fexpr, pinfo->usesSampling));
                            m_localIndexMap[fexpr] = newIndex;
                            collectSymbolNames(fexpr, newIndex);
                        }
                        else
                        {
                            collectSymbolNames(fexpr, localFunctionIndex);
                        }
                    }
                    else
                    {
                        collectSymbolNames(fexpr, localFunctionIndex);
                    }
                }
            }

            //
            //  collect the names for this function
            //

            m_functions.insert(F);

            if (F->usesOutputSize())
                m_needOutputSize = true;
            if (F->usesOutputST())
                m_needOutputST = true;

            //
            //  If this is an inline function give it a unique suffix
            //

            if (inlined)
            {
                ostringstream str;
                str << "_" << m_inlineMap.size();
                m_inlineMap[expr] = str.str();
            }

            for (size_t q = 0; q < exprArgs.size(); q++)
            {
                const BoundSymbol* B = exprArgs[q];
                const Symbol* S = B->symbol();

                if (S->isSpecial())
                {
                    if ((source && S->name() == "offset")
                        || (inlined && S->name() == "_offset"))
                    {
                        //
                        // skip this one. we'll have to generate its value
                        // depending on the context. This parameter is by
                        // filter functions (if they exist) otherwise its
                        // value should be the constant 0.0f.
                        //

                        m_bindingMap[B] =
                            NameBinding(B, "vec2(0.0, 0.0)", false);
                    }
                    else
                    {
                        m_bindingMap[B] = NameBinding(B, S->name(), true);
                    }
                }
                else
                {
                    const BoundExpression* Bexpr =
                        dynamic_cast<const BoundExpression*>(B);

                    if (source && S->type() == Symbol::Coord2DRectType)
                    {
                        //
                        //  Record both the gl_TexCoord number and a mapping
                        //  back to the source function expression. The mapping
                        //  back is required in order to e.g. find the sampler
                        //  for a givin inputImage.
                        //

                        // DO WE NEED THIS CODE? I THINK THIS CAN BE DONE
                        // USING THE STORED GRAPHID INSTEAD OF THESE MAPS

                        m_outputSTSet.insert(
                            expr->graphID()); // Not needed at all AFAIK
                        m_coordBindingMap[B] = m_totalST;
                        m_invSourceBindingMap[m_totalST] = expr;
                        m_totalST++;
                    }

                    m_localFunctions[localFunctionIndex].bsymbols.push_back(B);

                    ostringstream n;

                    m_nameCountMap[S->name()]++;
                    n << S->name() << "_" << m_nameCountMap[S->name()];

                    m_bindingMap[B] =
                        NameBinding(B, n.str(), (Bexpr ? false : true));
                }
            }
        }

        Program::~Program()
        {
            delete m_expr;
            delete m_main;
            releaseCompiledState();
        }

        string Program::recursiveOutputExpr(const Expression* expr,
                                            bool outputOffset)
        {
            //
            //  NOTE: this function has a bit of an "unnatural" structure to
            //  it. The NameBindings are a flat list in traversal order, so
            //  this function has to traverse in a similar fashion.
            //

            const ArgumentVector& exprArgs = expr->arguments();
            const Function* F = expr->function();
            const SymbolVector& symbols = F->parameters();

            vector<string> rargs;

            for (size_t i = 0; i < exprArgs.size(); i++)
            {
                if (const BoundExpression* B =
                        dynamic_cast<const BoundExpression*>(exprArgs[i]))
                {
                    if (B->symbol()->type() != Symbol::InputImageType)
                    {
                        Expression* Fap = B->value();
                        rargs.push_back(recursiveOutputExpr(Fap, outputOffset));
                    }
                }
            }

            ostringstream code;
            size_t index = 0;
            string suffix;

            if (m_inlineMap.count(expr) != 0)
            {
                suffix = m_inlineMap[expr];
            }

            code << F->callName() << suffix << "(";
            bool first = true;

            string samplerName;

            for (size_t q = 0; q < exprArgs.size(); q++)
            {
                const BoundSymbol* be = exprArgs[q];
                const BoundExpression* B =
                    dynamic_cast<const BoundExpression*>(be);

                if (B && B->symbol()->type() == Symbol::InputImageType)
                {
                    continue;
                }

                if (be->symbol()->type() == Symbol::OutputImageType)
                {
                    continue;
                }

                if (be->symbol()->type() == Symbol::Sampler2DRectType
                    && F->type() == Function::Source)
                {
                    const NameBinding& binding = m_bindingMap[be];
                    if (samplerName.empty())
                        samplerName = binding.name;
                }

                if (!first)
                    code << ", ";
                first = false;

                if (B)
                {
                    code << rargs[index++];
                }
                else
                {
                    if (be->symbol()->isCoordinate())
                    {
                        const Expression* expr =
                            m_invSourceBindingMap[m_coordBindingMap[be]];
                        code << "TexCoord" << expr->graphID() << ".xy";
                    }
                    else
                    {
                        const NameBinding& binding = m_bindingMap[be];

                        if (((F->isFilter()
                              && be->symbol()->name() == "_offset")
                             || (F->isSource()
                                 && be->symbol()->name() == "offset"))
                            && be->symbol()->isSpecial() && outputOffset)
                        {
                            code << "_offset";
                        }
                        else
                        {
                            code << binding.name;
                        }
                    }
                }
            }

            code << ")";

            return code.str();
        }

        //
        // given a uniform variable of type and name,
        // check if it has already been output before (find in uniforms)
        // if not, output to code
        //
        void outputUniformVariable(ostream& code, const string& type,
                                   const string& name)
        {
            code << "uniform " << type << " " << name << ";" << endl;
        }

        void Program::outputLocalFunction(ostream& code, const LocalFunction& l)
        {
            const bool ismain = l.root == m_expr;

            if (ismain)
            {
                code << "void main ()" << endl;
            }
            else
            {
                code << "vec4 " << l.name << " (const in vec2 _offset)" << endl;
            }

            code << "{" << endl;

            const char* glVersion = (const char*)glGetString(GL_VERSION);
            string fragColor =
                glVersion[0] <= '2' ? "gl_FragColor" : "FragColor";

            code << "    " << (ismain ? (fragColor + " = ") : "return ")
                 << recursiveOutputExpr(l.root, !ismain) << ";" << endl;

            code << "}" << endl;
        }

        bool Program::compile()
        {
            m_programId = glCreateProgram();

            if (!m_programId)
            {
                TWK_THROW_EXC_STREAM("ERROR: failed to create the GL program");
            }

            if (Shader::debuggingType() != Shader::NoDebugInfo)
            {
                cout << "INFO:" << endl
                     << "INFO: new shader program " << this << endl
                     << "INFO: " << endl;
            }

            //
            //  Create the main() shader source
            //

            ostringstream code;

            const char* glVersion = (const char*)glGetString(GL_VERSION);
            bool isGL3OrAbove = glVersion[0] > '2';
            string varying = isGL3OrAbove ? "in" : "varying";
            string varying_out = isGL3OrAbove ? "out" : "varying";
            string attribute = isGL3OrAbove ? "in" : "attribute";

            //
            //  Declare all the uniform variables before main() and the
            //  locals inside main.
            //

            std::vector<int> TexCoordIndices;

            for (BindingMap::const_iterator i = m_bindingMap.begin();
                 i != m_bindingMap.end(); ++i)
            {
                const NameBinding& b = (*i).second;
                const Symbol* S = b.bsymbol->symbol();

                if (b.uniform && !S->isSpecial() && !S->isCoordinate()
                    && !S->isOutputImage())
                {
                    outputUniformVariable(code, S->glslTypeName(), b.name);
                }
            }

            if (m_needOutputSize)
                outputUniformVariable(code, "vec2", "_windowSize");
            if (m_needOutputST)
                code << varying << " vec2 _fragCoord;" << endl;

            for (GraphIDSet::const_iterator i = m_outputSTSet.begin();
                 i != m_outputSTSet.end(); ++i)
            {
                code << varying << " vec2 TexCoord" << *i << ";" << endl;
            }

            for (GraphIDSet::const_iterator i = m_outputSizeSet.begin();
                 i != m_outputSizeSet.end(); ++i)
            {
                code << "uniform vec2 Size" << *i << ";" << endl;
            }

            // GL 3 deprecated gl_FragColor, so use a out vec4 instead

            if (isGL3OrAbove)
            {
                code << "out vec4 FragColor;" << endl;
            }

            //
            // Attach vertex shader
            //

            GLuint vshader = glCreateShader(GL_VERTEX_SHADER);
            ostringstream vertexCode;

            if (isGL3OrAbove)
            {
                vertexCode << "#version 150\n" << endl;
            }

            vertexCode << attribute << " vec2 in_Position;" << endl;
            vertexCode << "uniform mat4 projMatrix, modelviewMatrix;" << endl;

            for (GraphIDSet::const_iterator i = m_outputSTSet.begin();
                 i != m_outputSTSet.end(); ++i)
            {
                vertexCode << attribute << " vec2 in_TexCoord" << *i << ";"
                           << endl;
                vertexCode << varying_out << " vec2 TexCoord" << *i << ";"
                           << endl;
            }

            if (m_needOutputSize || m_needOutputST)
            {
                vertexCode << "uniform vec2 _windowSize;" << endl;
            }

            if (m_needOutputST)
            {
                vertexCode << varying_out << " vec2 _fragCoord;" << endl;
            }

            //
            //  main()
            //

            vertexCode << "void main()" << endl << "{" << endl;

            for (GraphIDSet::const_iterator i = m_outputSTSet.begin();
                 i != m_outputSTSet.end(); ++i)
            {
                vertexCode << "    TexCoord" << *i << " = in_TexCoord" << *i
                           << ";" << endl;
            }

            vertexCode << "    gl_Position = projMatrix * modelviewMatrix * "
                          "vec4(in_Position, 0, 1);"
                       << endl;

            if (m_needOutputST)
            {
                vertexCode << "    _fragCoord.x = 0.5 * (gl_Position.x + 1.0) "
                              "* _windowSize.x;"
                           << endl;
                vertexCode << "    _fragCoord.y = 0.5 * (gl_Position.y + 1.0) "
                              "* _windowSize.y;"
                           << endl;
            }

            vertexCode << "}" << endl;

            //
            //  Compile/Attach vertex shader
            //

            string vertexStr = vertexCode.str();
            m_vertexCode = vertexCode.str();
            const char* vertexStrPointer = m_vertexCode.c_str();

            glShaderSource(vshader, 1, &vertexStrPointer, NULL);
            glCompileShader(vshader);

            if (Shader::debuggingType() != Shader::NoDebugInfo)
            {
                cout << "INFO: ---- vertex shader source follows ----" << endl;
                outputAnnotatedCode(cout, m_vertexCode);
            }

            // print out log
            GLint infologLength = 0, status = GL_TRUE;
            glGetShaderiv(vshader, GL_COMPILE_STATUS, &status);

            if (status != GL_TRUE)
            {
                glGetShaderiv(vshader, GL_INFO_LOG_LENGTH, &infologLength);
                if (infologLength > 1)
                {
                    char* infoLog = new char[infologLength + 1];
                    int charsWritten = 0;
                    glGetShaderInfoLog(vshader, infologLength, &charsWritten,
                                       infoLog);
                    cout << infoLog << endl;
                    delete[] infoLog;
                }
            }

            TWK_GLDEBUG;
            glAttachShader(m_programId, vshader);
            TWK_GLDEBUG;

            //
            //  Output extern declarations
            //

            for (FunctionSet::const_iterator i = m_functions.begin();
                 i != m_functions.end(); ++i)
            {
                const Function* F = *i;
                if (F->isInline())
                    continue;
                code << F->prototype() << ";" << endl;
            }

            code << endl;

            //
            //  Output inline function prototypes
            //

            for (ExprSuffixMap::const_iterator i = m_inlineMap.begin();
                 i != m_inlineMap.end(); ++i)
            {
                const Expression* Fexpr = (*i).first;
                const Function* F = Fexpr->function();

                code << F->prototype((*i).second) << ";" << endl;
            }

            code << endl;

            //
            //  Output transplanted source functions
            //

            for (size_t i = 1; i < m_localFunctions.size(); i++)
            {
                if (m_localFunctions[i].shouldEmit)
                {
                    outputLocalFunction(code, m_localFunctions[i]);
                    code << endl;
                }
            }

            //
            //  Rewrite and shouldEmit inlined functions
            //

            for (ExprSuffixMap::const_iterator i = m_inlineMap.begin();
                 i != m_inlineMap.end(); ++i)
            {
                const Expression* Fexpr = (*i).first;
                const Function* F = Fexpr->function();
                const ArgumentVector& args = Fexpr->arguments();

                Function::StringVector argNames;
                Function::StringVector graphIDs;

                for (size_t q = 0; q < args.size(); q++)
                {
                    if (const BoundExpression* be =
                            dynamic_cast<const BoundExpression*>(args[q]))
                    {
                        const LocalFunction& L =
                            m_localFunctions[m_localIndexMap[be->value()]];
                        argNames.push_back(L.name);
                        graphIDs.push_back(L.graphID);
                    }
                }

                string rewriteF = F->rewrite((*i).second, argNames, graphIDs);
                code << rewriteF;
            }

            code << endl;

            //
            //  Compile any attached functions that have not yet been compiled
            //

            set<const Function*> attachedFuncs;

            for (FunctionSet::const_iterator i = m_functions.begin();
                 i != m_functions.end(); ++i)
            {
                const Function* F = *i;

                if (F->isInline())
                    continue;

                if (!F->isCompiled())
                {
                    if (!F->compile())
                    {
                        cout << "ERROR: function " << F->name()
                             << " failed to compile" << endl;
                        continue;
                    }
                }

                string p = F->prototype();

                if (!attachedFuncs.count(F))
                {
                    glAttachShader(m_programId, F->state()->shader);
                    if (Shader::debuggingType() != Shader::NoDebugInfo)
                        cout << "INFO: attached " << F->name() << endl;
                    attachedFuncs.insert(F);
                }
            }

            //
            //  The first LocalFunction is always main.
            //

            outputLocalFunction(code, m_localFunctions.front());

            //
            //  Write the execution pipeline
            //

            m_main = new Function("main", code.str(), Function::Main,
                                  SymbolVector(), SymbolVector());

            if (!m_main->compile())
            {
                cout << "ERROR: main failed to compile. Cannot build program"
                     << endl;
                return false;
            }

            glAttachShader(m_programId, m_main->state()->shader);
            glLinkProgram(m_programId);

            glGetProgramiv(m_programId, GL_LINK_STATUS, &status);

            if (status != GL_TRUE)
            {
                cout << "//" << endl;
                cout << "// VERTEX PROGRAM" << endl;
                cout << "//" << endl;

                outputAnnotatedCode(cout, m_vertexCode);

                for (FunctionSet::const_iterator i = m_functions.begin();
                     i != m_functions.end(); ++i)
                {
                    const Function* F = *i;

                    cout << "//" << endl;
                    cout << "// FUNCTION: " << F->name() << endl;
                    cout << "//" << endl;

                    outputAnnotatedCode(cout, F->source());

                    cout << endl;
                }

                cout << "//" << endl;
                cout << "// PROGRAM:" << endl;
                cout << "//" << endl;

                outputAnnotatedCode(cout, code.str());

                cout << "ERROR: compiling program: " << endl
                     << "       with functions: ";

                for (FunctionSet::const_iterator i = m_functions.begin();
                     i != m_functions.end(); ++i)
                {
                    cout << " " << (*i)->name();
                }
                cout << endl;

                GLint logsize = 0;
                glGetProgramiv(m_programId, GL_INFO_LOG_LENGTH, &logsize);
                if (logsize > 1)
                {
                    GLsizei rlen;
                    vector<char> buffer(logsize);
                    glGetProgramInfoLog(m_programId, logsize, &rlen,
                                        &buffer.front());

                    cout << &buffer.front() << endl;
                }

                releaseCompiledState();

                return false;
            }

            collectUniforms();
            collectAttribs();

            return true;
        }

        void Program::releaseCompiledState()
        {
            if (m_programId)
                glDeleteProgram(m_programId);
        }

        bool Program::validate() const
        {
            if (!m_programId)
            {
                cout << "ERROR: program validation failed because there is no "
                        "program"
                     << endl;
                return false;
            }

            glValidateProgram(m_programId);

            GLint status;
            glGetProgramiv(m_programId, GL_VALIDATE_STATUS, &status);

            if (status != GL_TRUE)
            {
                for (FunctionSet::const_iterator i = m_functions.begin();
                     i != m_functions.end(); ++i)
                {
                    cout << "//" << endl;
                    cout << "// FUNCTION: " << (*i)->name();
                    cout << "//" << endl;

                    outputAnnotatedCode(cout, (*i)->source());

                    cout << endl;
                }

                cout << "ERROR: validating program: " << endl
                     << "       with functions: ";

                for (FunctionSet::const_iterator i = m_functions.begin();
                     i != m_functions.end(); ++i)
                {
                    cout << " " << (*i)->name();
                }
                cout << endl;

                GLint logsize = 0;
                glGetProgramiv(m_programId, GL_INFO_LOG_LENGTH, &logsize);

                if (logsize > 1)
                {
                    GLsizei rlen;
                    vector<char> buffer(logsize);
                    glGetProgramInfoLog(m_programId, logsize, &rlen,
                                        &buffer.front());

                    cout << &buffer.front() << endl;
                }

                return false;
            }
            else
            {
                // cout << "INFO: program validation passed" << endl;
                return true;
            }
        }

        namespace
        {

            const Program::ImageAndCoordinateUnit* findTextureAssignment(
                const Symbol* S, const string& idhash, int plane,
                const Program::TextureUnitAssignments& channelAssignments)
            {
                for (size_t i = 0; i < channelAssignments.size(); i++)
                {
                    const Program::ImageAndCoordinateUnit& ca =
                        channelAssignments[i];

                    if ((ca.idhash == idhash || ca.graphID == idhash)
                        && ca.plane == plane)
                    {
                        assert(
                            (ca.textureTarget == GL_TEXTURE_1D
                             && S->type() == Symbol::Sampler1DType)
                            || (ca.textureTarget == GL_TEXTURE_2D
                                && S->type() == Symbol::Sampler2DType)
                            || (ca.textureTarget == GL_TEXTURE_3D
                                && S->type() == Symbol::Sampler3DType)
                            || (ca.textureTarget == GL_TEXTURE_RECTANGLE
                                && (S->type() == Symbol::Sampler2DRectType
                                    || S->type() == Symbol::Coord2DRectType)));

                        return &channelAssignments[i];
                    }
                }

                cout << "ERROR: Failed to find texture assignment:" << endl;
                cout << "ERROR:     ID = " << idhash << endl
                     << "ERROR:     plane = " << plane << endl
                     << "ERROR:     S = " << S->name() << endl;

                for (size_t i = 0; i < channelAssignments.size(); i++)
                {
                    const Program::ImageAndCoordinateUnit& ca =
                        channelAssignments[i];

                    cout << "ERROR: [" << i << "] -> " << ca.idhash << "("
                         << ca.graphID << ")"
                         << ", " << ca.plane << endl;
                }

                return 0;
            }

        } // namespace

        void Program::bind(const Expression* boundExpr,
                           const TextureUnitAssignments& assignments,
                           const TwkMath::Vec2f& windowSize) const
        {
            if (Shader::debuggingType() == Shader::AllDebugInfo)
            {
                cout << endl
                     << "======================================================"
                        "================"
                     << endl
                     << "ASSIGNMENTS:" << endl;

                for (size_t i = 0; i < assignments.size(); i++)
                    cout << assignments[i].textureUnit << " / "
                         << assignments[i].coordinateSet << " -> "
                         << assignments[i].idhash << " ("
                         << assignments[i].graphID << ")" << endl;

                cout << "---- bind ----" << endl;
            }

            size_t nameCount = 0;
            bind2(nameCount, boundExpr, m_expr, assignments, windowSize);

            //
            //  Bind known values that come from TextureUnitAssignments or
            //  output device.
            //

            if (m_needOutputSize)
            {
                unsigned int location = uniformLocation("_windowSize");
                glUniform2fv(location, 1, &(windowSize[0]));

                if (Shader::debuggingType() == Shader::AllDebugInfo)
                {
                    cout << "INFO: binding variable vec2 _windowSize at "
                         << location << " :: value = " << windowSize[0] << ", "
                         << windowSize[1] << endl;
                }
            }

            for (size_t i = 0; i < assignments.size(); i++)
            {
                const ImageAndCoordinateUnit& icu = assignments[i];

                if (icu.outputSize)
                {
                    string name = "Size" + icu.graphID;
                    int location = uniformLocation(name);

                    if (location >= 0)
                    {
                        glUniform2f(location, icu.uncropWidth,
                                    icu.uncropHeight);

                        if (Shader::debuggingType() == Shader::AllDebugInfo)
                        {
                            cout << "INFO: binding variable vec2 " << name
                                 << " at " << location
                                 << " :: value = " << icu.uncropWidth << ", "
                                 << icu.uncropHeight << endl;
                        }
                    }
                    else
                    {
                        cout << "ERROR: failed to bind " << name << endl;
                    }
                }
            }
        }

        void Program::bind2(size_t& nameCount, const Expression* boundExpr,
                            const Expression* unboundExpr,
                            const TextureUnitAssignments& assignments,
                            const TwkMath::Vec2f& windowSize) const
        {
            const ArgumentVector& boundArgs = boundExpr->arguments();
            const ArgumentVector& unboundArgs = unboundExpr->arguments();
            const Function* F = boundExpr->function();
            const size_t nargs = boundArgs.size();

            for (size_t i = 0; i < nargs; i++)
            {
                if (BoundExpression* be =
                        dynamic_cast<BoundExpression*>(boundArgs[i]))
                {
                    BoundExpression* rbe =
                        dynamic_cast<BoundExpression*>(unboundArgs[i]);
                    bind2(nameCount, be->value(), rbe->value(), assignments,
                          windowSize);
                }
            }

            for (size_t q = 0; q < nargs; q++)
            {
                BoundSymbol* b = boundArgs[q];
                BoundSymbol* rb = unboundArgs[q];
                const Symbol* S = b->symbol();

                if (BoundExpression* be = dynamic_cast<BoundExpression*>(b))
                {
                    nameCount++;
                    continue;
                }

                // const Program::NameBinding& nb = nameBindings()[nameCount++];
                BindingMap::const_iterator bi = m_bindingMap.find(rb);
                const Program::NameBinding& nb = (*bi).second;

                const string& name = nb.name;
                assert(nb.bsymbol->symbol() == S);
                GLint location = -1;
                location = uniformLocation(name);

                void* vp = b->valuePointer();

                if (location == -1)
                    continue; // not assignable

                if (Shader::debuggingType() == Shader::AllDebugInfo)
                {
                    cout << "INFO: binding variable " << S->glslTypeName()
                         << " " << name << " at " << location << " :: value = ";

                    b->output(cout);
                    cout << endl;
                }

                switch (S->type())
                {
                case Symbol::FloatType:
                    if (S->isSpecial() && S->name() == "time")
                    {
                        //
                        // NOTE: this is *wall clock* time. Its pretty much
                        // the only value which can be assigned during bind
                        // time.
                        //

                        GLfloat elapsed = shaderClock.elapsed();
                        glUniform1fv(location, 1, &elapsed);
                    }
                    else
                    {
                        glUniform1fv(location, 1, (GLfloat*)vp);
                    }
                    break;

                case Symbol::Vec2fType:
                    glUniform2fv(location, 1, (GLfloat*)vp);
                    break;
                case Symbol::Vec3fType:
                    glUniform3fv(location, 1, (GLfloat*)vp);
                    break;
                case Symbol::Vec4fType:
                    glUniform4fv(location, 1, (GLfloat*)vp);
                    break;

                case Symbol::BoolType:
                case Symbol::IntType:
                    glUniform1iv(location, 1, (GLint*)vp);
                    break;

                case Symbol::Vec2bType:
                case Symbol::Vec2iType:
                    glUniform2iv(location, 1, (GLint*)vp);
                    break;

                case Symbol::Vec3bType:
                case Symbol::Vec3iType:
                    glUniform3iv(location, 1, (GLint*)vp);
                    break;

                case Symbol::Vec4bType:
                case Symbol::Vec4iType:
                    glUniform4iv(location, 1, (GLint*)vp);
                    break;

                case Symbol::Matrix4fType:
                    glUniformMatrix4fv(location, 1, true, (GLfloat*)vp);
                    break;
                case Symbol::Matrix3fType:
                    glUniformMatrix3fv(location, 1, true, (GLfloat*)vp);
                    break;
                case Symbol::Matrix2fType:
                    glUniformMatrix2fv(location, 1, true, (GLfloat*)vp);
                    break;

                case Symbol::FloatArrayType:
                    glUniform1fv(location, S->width(), (GLfloat*)vp);
                    break;
                case Symbol::BoolArrayType:
                case Symbol::IntArrayType:
                    glUniform1iv(location, S->width(), (GLint*)vp);
                    break;

                case Symbol::Coord2DRectType:

                    if (BoundImageCoordName* bcoord =
                            dynamic_cast<BoundImageCoordName*>(b))
                    {
                        const string& idhash = bcoord->value().name;

                        if (const ImageAndCoordinateUnit* icu =
                                findTextureAssignment(S, idhash, 0,
                                                      assignments))
                        {
                            // bcoord->value().index = icu->coordinateSet;
                        }
                    }
                    break;

                case Symbol::Sampler1DType:
                case Symbol::Sampler2DType:
                case Symbol::Sampler2DRectType:
                case Symbol::Sampler3DType:

                    if (const BoundSampler* bsampler =
                            dynamic_cast<const BoundSampler*>(b))
                    {
                        ImageOrFB ifb = bsampler->value();
                        const string idhash = ifb.fb ? ifb.fb->identifier()
                                                     : ifb.image->graphID();
                        const size_t plane = bsampler->value().plane;

                        if (const ImageAndCoordinateUnit* icu =
                                findTextureAssignment(S, idhash, plane,
                                                      assignments))
                        {
                            glUniform1i(location, icu->textureUnit);
                            TWK_GLDEBUG;
                        }
                        else
                        {
                            cout << "ERROR: bound expr = " << endl;
                            boundExpr->output(cout);

                            cout << endl << "ERROR: unbound expr = " << endl;
                            unboundExpr->output(cout);

                            cout << endl << "ERROR: assignments = " << endl;

                            for (size_t i = 0; i < assignments.size(); i++)
                                cout << assignments[i].textureUnit << " / "
                                     << assignments[i].coordinateSet << " -> "
                                     << assignments[i].idhash << " ("
                                     << assignments[i].graphID << ")" << endl;
                        }
                    }
                    break;

                default:
                    //
                    //    Not used -- don't output
                    //
                    break;
                }

                TWK_GLDEBUG;
            }
        }

        //----------------------------------------------------------------------

        ProgramCache::ProgramCache() {}

        ProgramCache::~ProgramCache() { flush(); }

        void ProgramCache::flush()
        {
            for (ProgramCacheMap::iterator i = m_programCache.begin();
                 i != m_programCache.end(); ++i)
            {
                //
                //  (*i).first will be deleted when (*i).second is deleted.
                //

                delete (*i).second;
            }

            m_programCache.clear();

            Function::deleteRetired();
        }

        const Program* ProgramCache::select(const Expression* A)
        {
            //
            //  Create a vector of functions as the program key
            //

            ProgramCacheMap::const_iterator i = m_programCache.find(A);

            if (i != m_programCache.end())
            {
                return i->second;
            }
            else
            {
                Expression* Aunbound = A->copyUnbound();
                Program* p = new Program(Aunbound);

                if (p->compile())
                {
                    m_programCache[Aunbound] = p;
                }
                else
                {
                    delete p;
                    p = 0;
                }

                if (!p)
                    TWK_THROW_EXC_STREAM(
                        "ERROR: failed to select the GL program");
                return p;
            }
        }

    } // namespace Shader
} // namespace IPCore
