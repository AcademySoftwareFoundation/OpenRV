//*****************************************************************************
// Copyright (c) 2024 Autodesk, Inc.
// All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0
//
//*****************************************************************************

// IMPORTANT: This file (not the template) is auto-generated by qt2mu.py script.
//            The prefered way to do a fix is to handrolled it or modify the
//            qt2mu.py script. If it is not possible, manual editing is ok but
//            it could be lost in future generations.

#include <MuQt6/qtUtils.h>
#include <MuQt6/QBitmapType.h>
#include <MuQt6/QActionType.h>
#include <MuQt6/QWidgetType.h>
#include <Mu/Alias.h>
#include <Mu/BaseFunctions.h>
#include <Mu/ClassInstance.h>
#include <Mu/Exception.h>
#include <Mu/Function.h>
#include <Mu/MemberFunction.h>
#include <Mu/MemberVariable.h>
#include <Mu/Node.h>
#include <Mu/ParameterVariable.h>
#include <Mu/ReferenceType.h>
#include <Mu/SymbolicConstant.h>
#include <Mu/Thread.h>
#include <Mu/Value.h>
#include <MuLang/MuLangContext.h>
#include <MuLang/StringType.h>
#include <QtGui/QtGui>
#include <QtWidgets/QtWidgets>
#include <QtSvg/QtSvg>
#include <QSvgWidget>
#include <QtNetwork/QtNetwork>
#include <MuQt6/QPixmapType.h>
#include <MuQt6/QImageType.h>
#include <MuQt6/QTransformType.h>

namespace Mu
{
    using namespace std;

    QBitmapType::Instance::Instance(const Class* c)
        : ClassInstance(c)
    {
    }

    QBitmapType::QBitmapType(Context* c, const char* name, Class* super)
        : Class(c, name, super)
    {
    }

    QBitmapType::~QBitmapType() {}

    static NODE_IMPLEMENTATION(__allocate, Pointer)
    {
        QBitmapType::Instance* i =
            new QBitmapType::Instance((Class*)NODE_THIS.type());
        QBitmapType::registerFinalizer(i);
        NODE_RETURN(i);
    }

    void QBitmapType::registerFinalizer(void* o)
    {
        GC_register_finalizer(o, QBitmapType::finalizer, 0, 0, 0);
    }

    void QBitmapType::finalizer(void* obj, void* data)
    {
        QBitmapType::Instance* i =
            reinterpret_cast<QBitmapType::Instance*>(obj);
        delete i;
    }

    //----------------------------------------------------------------------
    //  PRE-COMPILED FUNCTIONS

    Pointer qt_QBitmap_QBitmap_QBitmap_QBitmap(Mu::Thread& NODE_THREAD,
                                               Pointer param_this)
    {
        MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
        setpaintdevice(param_this, QBitmap());
        return param_this;
    }

    Pointer qt_QBitmap_QBitmap_QBitmap_QBitmap_int_int(Mu::Thread& NODE_THREAD,
                                                       Pointer param_this,
                                                       int param_width,
                                                       int param_height)
    {
        MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
        int arg1 = (int)(param_width);
        int arg2 = (int)(param_height);
        setpaintdevice(param_this, QBitmap(arg1, arg2));
        return param_this;
    }

    void qt_QBitmap_clear_void_QBitmap(Mu::Thread& NODE_THREAD,
                                       Pointer param_this)
    {
        MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
        QBitmap& arg0 = getqtype<QBitmapType>(param_this);
        arg0.clear();
    }

    void qt_QBitmap_swap_void_QBitmap_QBitmap(Mu::Thread& NODE_THREAD,
                                              Pointer param_this,
                                              Pointer param_other)
    {
        MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
        QBitmap& arg0 = getqtype<QBitmapType>(param_this);
        QBitmap arg1 = getqtype<QBitmapType>(param_other);
        arg0.swap(arg1);
    }

    Pointer qt_QBitmap_transformed_QBitmap_QBitmap_QTransform(
        Mu::Thread& NODE_THREAD, Pointer param_this, Pointer param_matrix)
    {
        MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
        const QBitmap& arg0 = getqtype<QBitmapType>(param_this);
        const QTransform arg1 = getqtype<QTransformType>(param_matrix);
        return makeqtype<QBitmapType>(c, arg0.transformed(arg1), "qt.QBitmap");
    }

    Pointer qt_QBitmap_fromImage_QBitmap_QImage_int(Mu::Thread& NODE_THREAD,
                                                    Pointer param_image,
                                                    int param_flags)
    {
        MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
        const QImage arg0 = getqtype<QImageType>(param_image);
        Qt::ImageConversionFlags arg1 = (Qt::ImageConversionFlags)(param_flags);
        return makeqtype<QBitmapType>(c, QBitmap::fromImage(arg0, arg1),
                                      "qt.QBitmap");
    }

    Pointer qt_QBitmap_fromPixmap_QBitmap_QPixmap(Mu::Thread& NODE_THREAD,
                                                  Pointer param_pixmap)
    {
        MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
        const QPixmap arg0 = getqtype<QPixmapType>(param_pixmap);
        return makeqtype<QBitmapType>(c, QBitmap::fromPixmap(arg0),
                                      "qt.QBitmap");
    }

    static NODE_IMPLEMENTATION(_n_QBitmap0, Pointer)
    {
        NODE_RETURN(qt_QBitmap_QBitmap_QBitmap_QBitmap(
            NODE_THREAD, NONNIL_NODE_ARG(0, Pointer)));
    }

    static NODE_IMPLEMENTATION(_n_QBitmap1, Pointer)
    {
        NODE_RETURN(qt_QBitmap_QBitmap_QBitmap_QBitmap_int_int(
            NODE_THREAD, NONNIL_NODE_ARG(0, Pointer), NODE_ARG(1, int),
            NODE_ARG(2, int)));
    }

    static NODE_IMPLEMENTATION(_n_clear0, void)
    {
        qt_QBitmap_clear_void_QBitmap(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer));
    }

    static NODE_IMPLEMENTATION(_n_swap0, void)
    {
        qt_QBitmap_swap_void_QBitmap_QBitmap(
            NODE_THREAD, NONNIL_NODE_ARG(0, Pointer), NODE_ARG(1, Pointer));
    }

    static NODE_IMPLEMENTATION(_n_transformed0, Pointer)
    {
        NODE_RETURN(qt_QBitmap_transformed_QBitmap_QBitmap_QTransform(
            NODE_THREAD, NONNIL_NODE_ARG(0, Pointer), NODE_ARG(1, Pointer)));
    }

    static NODE_IMPLEMENTATION(_n_fromImage0, Pointer)
    {
        NODE_RETURN(qt_QBitmap_fromImage_QBitmap_QImage_int(
            NODE_THREAD, NODE_ARG(0, Pointer), NODE_ARG(1, int)));
    }

    static NODE_IMPLEMENTATION(_n_fromPixmap0, Pointer)
    {
        NODE_RETURN(qt_QBitmap_fromPixmap_QBitmap_QPixmap(
            NODE_THREAD, NODE_ARG(0, Pointer)));
    }

    void QBitmapType::load()
    {
        USING_MU_FUNCTION_SYMBOLS;
        MuLangContext* c = static_cast<MuLangContext*>(context());
        Module* global = globalModule();

        const string typeName = name();
        const string refTypeName = typeName + "&";
        const string fullTypeName = fullyQualifiedName();
        const string fullRefTypeName = fullTypeName + "&";
        const char* tn = typeName.c_str();
        const char* ftn = fullTypeName.c_str();
        const char* rtn = refTypeName.c_str();
        const char* frtn = fullRefTypeName.c_str();

        scope()->addSymbols(new ReferenceType(c, rtn, this),

                            new Function(c, tn, BaseFunctions::dereference,
                                         Cast, Return, ftn, Args, frtn, End),

                            EndArguments);

        addSymbols(
            new Function(c, "__allocate", __allocate, None, Return, ftn, End),

            EndArguments);

        addSymbols(EndArguments);

        addSymbols(
            // enums
            // member functions
            new Function(c, "QBitmap", _n_QBitmap0, None, Compiled,
                         qt_QBitmap_QBitmap_QBitmap_QBitmap, Return,
                         "qt.QBitmap", Parameters,
                         new Param(c, "this", "qt.QBitmap"), End),
            new Function(c, "QBitmap", _n_QBitmap1, None, Compiled,
                         qt_QBitmap_QBitmap_QBitmap_QBitmap_int_int, Return,
                         "qt.QBitmap", Parameters,
                         new Param(c, "this", "qt.QBitmap"),
                         new Param(c, "width", "int"),
                         new Param(c, "height", "int"), End),
            // MISSING: QBitmap (QBitmap; QBitmap this, string fileName, "const
            // char *" format)
            new Function(c, "clear", _n_clear0, None, Compiled,
                         qt_QBitmap_clear_void_QBitmap, Return, "void",
                         Parameters, new Param(c, "this", "qt.QBitmap"), End),
            new Function(c, "swap", _n_swap0, None, Compiled,
                         qt_QBitmap_swap_void_QBitmap_QBitmap, Return, "void",
                         Parameters, new Param(c, "this", "qt.QBitmap"),
                         new Param(c, "other", "qt.QBitmap"), End),
            new Function(c, "transformed", _n_transformed0, None, Compiled,
                         qt_QBitmap_transformed_QBitmap_QBitmap_QTransform,
                         Return, "qt.QBitmap", Parameters,
                         new Param(c, "this", "qt.QBitmap"),
                         new Param(c, "matrix", "qt.QTransform"), End),
            // MISSING: QVariant ("QVariant operator"; QBitmap this)
            // static functions
            // MISSING: fromData (QBitmap; QSize size, "const uchar *" bits,
            // flags QImage::Format monoFormat)
            new Function(
                c, "fromImage", _n_fromImage0, None, Compiled,
                qt_QBitmap_fromImage_QBitmap_QImage_int, Return, "qt.QBitmap",
                Parameters, new Param(c, "image", "qt.QImage"),
                new Param(c, "flags", "int", Value((int)Qt::AutoColor)), End),
            // MISSING: fromImage (QBitmap; "QImage & &" image, flags
            // Qt::ImageConversionFlags flags)
            new Function(c, "fromPixmap", _n_fromPixmap0, None, Compiled,
                         qt_QBitmap_fromPixmap_QBitmap_QPixmap, Return,
                         "qt.QBitmap", Parameters,
                         new Param(c, "pixmap", "qt.QPixmap"), End),
            EndArguments);
        globalScope()->addSymbols(EndArguments);
        scope()->addSymbols(EndArguments);
    }

} // namespace Mu
